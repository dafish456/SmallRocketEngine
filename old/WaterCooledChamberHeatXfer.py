# -*- coding: utf-8 -*-
"""WaterCooledChamberHeatXfer.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1mHXfGzA7K6lK85c1AFKvvj7-jgib4RnG
"""

!pip install RocketCEA

pip install pint

from rocketcea.cea_obj import CEA_Obj
from pint import UnitRegistry
import matplotlib.pyplot as plt
import numpy as np

ureg = UnitRegistry()
ureg.define('WattsPerMeterKelvin = [watt]/([meter]*[kelvin]) = W/m*K')
ureg.define('JoulesPerKilogramKelvin = [joule]/([kilogram]*[kelvin]) = J/kg*K')
ureg.define('PascalSecond = [Pa]*[second] = Pa*s')


runObj = CEA_Obj(oxName='LOX',fuelName='CH4')
Pc = 1500 * ureg.psi
eps = 35
MR = 3.6
contractionRatio = 4.0
output = 'siunits'
wallThickness = 0.0025 * ureg.inches
wallThickness.ito(ureg.meter)

def extractValues(wholeStr, startStr, endStr, units = None):
  idx1 = wholeStr.index(startStr)
  idx2 = wholeStr.index(endStr)

  res = ''
  # getting elements in between
  for idx in range(idx1 + len(startStr) + 1, idx2):
      res = res + wholeStr[idx]

  vals = res.split()

  if units != None:
    vals = [float(x)*ureg(units) for x in vals]
  else:
    vals = [float(x) for x in vals]

  return vals

def convertTo(desiredUnits, values):
  convertedValues = [0]*len(values)

  for i in range(0, len(values)):
    convertedValues[i] = values[i].to(desiredUnits)

  return convertedValues


def GRCop42_k_at(tempQty):
  if tempQty.magnitude >=  260 + 273.15:
    m = (303-317)/(537.8-260)
    x1 = 537.8 + 273.15
    y1 = 303
  elif tempQty.magnitude >= 25 + 273.15:
    m = (317-323)/(260-25)
    x1 = 260 + 273.15
    y1 = 317
  k = (m*(tempQty.magnitude-x1) + y1)*ureg.WattsPerMeterKelvin
  return k

def orderAlongX(unorderedList):
  orderedList = []

  for i in range(0,len(MachNumbers)):
    if MachNumbers[i] >= 0.0 and MachNumbers[i] < 1.0:
      orderedList.append(unorderedList[i])

  for i in range(0,len(MachNumbers)):
    if MachNumbers[i] >= 1.0:
      orderedList.append(unorderedList[i])

  # if unorderedList has units, orderedList will have them. If not, orderedList won't have units
  return orderedList

run = runObj.get_full_cea_output(Pc=Pc.magnitude,MR=MR,eps=[15,eps],subar=[4,3,2],frozen=0,show_transport=1,output=output)

staticPressures = extractValues(run, 'P, BAR', 'T, K', 'bar')
convertTo('pascal',staticPressures)

gasTempsK = extractValues(run, 'T, K', 'RHO, KG/CU M', 'K')

specificHeats = extractValues(run, 'Cp, KJ/(KG)(K)', 'GAMMAs') # CEA outputs this quantity in kJ/(kg*K)
specificHeats = [specificHeat*1000*ureg.JoulesPerKilogramKelvin for specificHeat in specificHeats] # convert to J/(kg*K)

gammas = extractValues(run, 'GAMMAs', 'SON VEL,M/SEC')

MachNumbers = extractValues(run, 'MACH NUMBER', 'TRANSPORT PROPERTIES (GASES ONLY)')

viscosities = extractValues(run, 'VISC,MILLIPOISE', 'WITH EQUILIBRIUM REACTIONS') # CEA outputs this quantity in millipoise
viscosities = [viscosity/10**4*ureg.PascalSecond for viscosity in viscosities] # convert to Pa*s

prandtlNumbers = extractValues(run, 'PRANDTL NUMBER', 'WITH FROZEN REACTIONS')

recovery_factors = [x**(1/3) for x in prandtlNumbers]

areaRatios = extractValues(run, 'Ae/At','CSTAR, M/SEC')
areaRatios = [contractionRatio] + areaRatios

C_star = np.array(extractValues(run, 'CSTAR, M/SEC', 'CF')) # CEA outputs this quantity in m/s
C_star = np.unique(C_star)[0]

# solve for adiabatic wall temps
adiabatic_wall_temps_vals = []
adiabatic_wall_temps = []

i = 0
while i < len(gasTempsK):
  mag = gasTempsK[i].magnitude*(1+recovery_factors[i]*((gammas[i]-1)/2)*MachNumbers[i]**2)
  adiabatic_wall_temps_vals.append(mag)
  adiabatic_wall_temps.append(mag*ureg.K)
  i+=1

# plt.scatter(list(range(0,len(adiabatic_wall_temps_vals))),adiabatic_wall_temps_vals)
# plt.title('Adiabatic Wall Temperature')
# plt.xlabel('Data Point number')
# plt.ylabel('Temperature [K]')
# plt.show()

# calculate Bartz convection coefficients
viscosities = orderAlongX(viscosities)
specificHeats = orderAlongX(specificHeats)
prandtlNumbers = orderAlongX(prandtlNumbers)
areaRatios = orderAlongX(areaRatios)
gammas = orderAlongX(gammas)


print("I need to define upstream and downstream throat radii of curvature, determine throat radius/diam, extract Tc_ns")
print("How can wall temp be determined independently of what's happening on other side of wall?")


# calculate heat flux at axial stations, apply standard scaling
# adiabatic_wall_temps_vals = orderAlongX(adiabatic_wall_temps_vals)
# q = []
# for i in range(0,len(adiabatic_wall_temps_vals)):
#   q[i] = hg[i]*(adiabatic_wall_temps_vals[i] - T_wg)